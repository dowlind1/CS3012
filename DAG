public class DAG{
        private int V;//# of vertices in graph
        private int E;//# of edges in graph
        private int[][] adj; //adjacency list for vertex v - changed to 2D array
	private int[] outdegree;//outdegree of vertex v
        private int[] indegree; // indegree of vertex v
       
    //constructor to initialize and empty graph with size V
    public DAG(int V){
        if(V<0){
            throw new IllegalArgumentException("Number of vertices in the DAG must be greater than 0.");
        }
        else{
            this.V = V;
            this.E = 0;
            indegree = new boolean[V];
            indegree = new int[V];
	    outdegree = new int[V];
       	    marked = new boolean[V];
	    adj = new int[V][V];
	    for(int i = 0; i<V; i++){//sets up an empty graph in 2D array
		for(int j=0;j<V;j++){
		    adj[i][j] = 0;
		}
	    }
        }
    }
    
    //returns number of vertices in DAG
    public int V(){
        return V;
    }
    
    //returns number of edges in DAG
    public int E(){
        return E;
    }
    
    //throws illegal exception if the vertex put in, is out of bounds
    private void validateVertex(int v){
        if((v<0)||(v>=V)){
            throw new IllegalArgumentException("Edgesless than one means no verices are joined, and if there is a cycle it cannot be moved");
        }
    }
    
    //adds directed edge from v to w
    public void addEdge(int v, int w){
        validateVertex(v);
		validateVertex(w);
		adj[v][w]=1;
		indegree[w]++;
		outdegree[v]=++;
		E++;
    }
    
    //Removes an edge from v to w
    public void removeEdge(int v, int w){
        validateVertex(v);
	validateVertex(w);
	adj[v][w]=0;
	indegree[w]--;
	outdegree[v]--;
	E--;
    }
    
    //returns the number of directed edges out of vertex v
    public int outdegree(int v){
    	validateVertex(v);
	return outdegree[v];
    }
    
    //returns the number of directed edges into vertex v
    public int indegree(int v){
   	validateVertex(v);
	return indegree[v];
    }
    
    //returns the vertices adjacent from vertex v
    public int[] adj(int v){
    	validateVertex(v);
	int[] temp = new int[outdegree[v]];
	int count =0;
	for(int i=0;i<V;i++){
	    if(adj[v][i]==1){
		temp[count]=i;
		count++;
    	    }
	}
	return temp;
    }
    
    //returns true if the graph contains acycle, else false
    public boolean hasCycle(){
    
    }
    
    //checks to see if the graph is acyclic
    private boolean isCyclic(int v, boolean marked[], int parent){
    
    }
    
    //the function to do a DFS traversal, using recursion
    public void DFS(int v){
    
    }
    
    private void DFS(int v, boolean[] marked){
    
    }
    
    //prints BFS traversal from a given source s
    private void BFS(int s){
    
    }
    
    //reverse the BFS traversal
    private void reverseBFS(){

    }
}
